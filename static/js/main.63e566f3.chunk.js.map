{"version":3,"sources":["VerticalBars/VerticalBar.jsx","VerticalBars/VerticalBarContainer.jsx","ControlBar/ResetButton.jsx","ControlBar/SortButton.jsx","ControlBar/TestButton.jsx","ControlBar/ControlContainer.jsx","mergeSort.js","quickSort.js","bubbleSort.js","heapSort.js","App.js","reportWebVitals.js","index.js"],"names":["VerticalBar","props","classText","this","currentBar","currentPartition","className","style","height","heightVal","React","Component","VerticalBarContainer","outArr","barState","barObjects","map","element","idx","barHeight","partitionBar","ResetButton","handleClick","bind","resetBars","barCount","onClick","SortButton","sortBars","text","TestButton","testSort","ControlContainer","mergeSort","quickSort","bubbleSort","heapSort","arrayToSort","animationArray","length","mergeSortRecursiveCall","leftIndex","rightIndex","arrayLength","midPoint","Math","floor","arrayToMerge","mergedArray","slice","i","j","k","push","mergeLeftAndRightArrays","quickSortRecursiveCall","getMedianPivotIndex","pivotIndex","swapBars","pivotValue","travellingPivotIndex","partitionArray","leftPivot","rightPivot","indexObjectArray","index","value","lowestIndexVal","reduce","accumulator","min","Infinity","highestIndexVal","max","medObject","filter","indexOne","indexTwo","originalArray","indexOneValue","indexTwoValue","swapCounter","heapSortRecursiveCall","rootIndex","smallestIndex","App","state","mergeSortWrapper","quickSortWrapper","bubbleSortWrapper","heapSortWrapper","animateMergeSort","animateQuickSort","animateBubbleSort","animateHeapSort","arr","random","setState","testArrayLength","mergeSortedArray","quickSortedArray","bubbleSortedArray","heapSortedArray","jsSortedArray","sort","a","b","arraysEqual","console","log","unsortedArray","tempArray","skippedSteps","cache","opArray","locationOne","locationTwo","undoLastAnimation","processAnimation","newArray","setTimeout","animType","arrayToAnim","barToMove","JSON","parse","stringify","splice","barOne","barTwo","barPivot","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.63e566f3.chunk.js","sourcesContent":["import React from 'react'\r\nimport '../App.css'\r\n\r\nexport default class VerticalBar extends React.Component {\r\n  constructor( props ) {\r\n    super( props );\r\n  }\r\n  render() {\r\n    let classText =\r\n      `vertical-bar\r\n      ${this.props.currentBar ? 'current-bar' : ''}\r\n      ${this.props.currentPartition ? 'partition-bar' : ''}`\r\n    return (\r\n      <div className={classText} style={{height: this.props.heightVal}}></div>\r\n    )\r\n  }\r\n}","import VerticalBar from './VerticalBar.jsx'\r\n\r\nexport default function VerticalBarContainer( props ) {\r\n  let outArr = props.barState.barObjects.map( ( element, idx ) =>\r\n    <VerticalBar key={idx}\r\n                 heightVal={element.barHeight}\r\n                 currentBar={element.currentBar}\r\n                 currentPartition={element.partitionBar} /> )\r\n  return (\r\n    <div className='bar-container'>\r\n      {outArr}\r\n    </div>\r\n  );\r\n}","import React from 'react'\r\n\r\nexport default class ResetButton extends React.Component {\r\n  constructor( props ) {\r\n    super( props );\r\n    this.handleClick = this.handleClick.bind( this );\r\n  }\r\n\r\n  handleClick() {\r\n    this.props.resetBars( this.props.barCount );\r\n  }\r\n  render() {\r\n    return (\r\n      <button className=\"btn btn-primary\" onClick={this.handleClick}>Reset</button>\r\n    )\r\n  }\r\n\r\n}","import React from 'react'\r\n\r\nexport default class SortButton extends React.Component {\r\n  constructor( props ) {\r\n    super( props );\r\n    this.handleClick = this.handleClick.bind( this );\r\n  }\r\n\r\n  handleClick() {\r\n    this.props.sortBars();\r\n  }\r\n  render() {\r\n    return (\r\n      <button className=\"btn btn-primary\" onClick={this.handleClick}>{this.props.text}</button>\r\n    )\r\n  }\r\n\r\n}\r\n","import React from 'react'\r\n\r\nexport default class TestButton extends React.Component {\r\n  constructor( props ) {\r\n    super( props );\r\n    this.handleClick = this.handleClick.bind( this );\r\n  }\r\n\r\n  handleClick() {\r\n    this.props.testSort( this.props.barCount );\r\n  }\r\n  render() {\r\n    return (\r\n      <button className=\"btn btn-primary\" onClick={this.handleClick}>Test</button>\r\n    )\r\n  }\r\n\r\n}","import ResetButton from './ResetButton.jsx';\r\nimport SortButton from './SortButton.jsx';\r\nimport TestButton from './TestButton.jsx';\r\n\r\nexport default function ControlContainer( props ) {\r\n  return (\r\n    <div className='control-container'>\r\n      <ResetButton barCount={props.barCount} resetBars={props.resetBars} />\r\n      <SortButton sortBars={props.mergeSort} text='Merge Sort' />\r\n      <SortButton sortBars={props.quickSort} text='Quick Sort' />\r\n      <SortButton sortBars={props.bubbleSort} text='Bubble Sort' />\r\n      <SortButton sortBars={props.heapSort} text='Heap Sort' />\r\n      <TestButton testSort={props.testSort} />\r\n    </div>\r\n  )\r\n}","export default function mergeSort(arrayToSort){\r\n  let animationArray = [];\r\n  let sortedArray = [];\r\n  if (arrayToSort.length < 2) { return [arrayToSort, animationArray] }\r\n  [sortedArray, animationArray] = mergeSortRecursiveCall(arrayToSort, 0, arrayToSort.length, animationArray)\r\n  return [sortedArray, animationArray];\r\n}\r\n\r\nfunction mergeSortRecursiveCall(arrayToSort, leftIndex, rightIndex, animationArray){\r\n  //Return the input array if indices are the same\r\n  let arrayLength = rightIndex - leftIndex;\r\n  if (arrayLength < 2) {return [arrayToSort, animationArray]}\r\n\r\n  //Define the splitting point of the array\r\n  let midPoint = Math.floor(arrayLength / 2) + leftIndex;\r\n  //Recursively call this function on both halves of the array\r\n  [arrayToSort, animationArray] = mergeSortRecursiveCall(arrayToSort, leftIndex, midPoint, animationArray);\r\n  [arrayToSort, animationArray] = mergeSortRecursiveCall(arrayToSort, midPoint, rightIndex, animationArray);\r\n  //Merge the sorted left and right arrays\r\n  let sortedArray = [];\r\n  [sortedArray, animationArray] = mergeLeftAndRightArrays(arrayToSort, leftIndex, midPoint, rightIndex, animationArray)\r\n  return [sortedArray, animationArray];\r\n}\r\n\r\nfunction mergeLeftAndRightArrays(arrayToMerge, leftIndex, midPoint, rightIndex, animationArray){\r\n  let mergedArray = arrayToMerge.slice();\r\n\r\n  let i = leftIndex; //Index for left array\r\n  let j = midPoint; //Index for right array\r\n\r\n  //Iterate over each position in the final merged array, adding the\r\n  //lowest value from the left or right array as appropriate.\r\n  for (let k = leftIndex; k < rightIndex; k++) {\r\n    if (i >= midPoint) {\r\n      mergedArray[k] = arrayToMerge[j];\r\n      animationArray.push([j,k]);\r\n      j++;\r\n    }else if (j >= rightIndex) {\r\n      mergedArray[k] = arrayToMerge[i];\r\n      animationArray.push([i,k]);\r\n      i++;\r\n    }else{\r\n      if(arrayToMerge[i].barHeight < arrayToMerge[j].barHeight){\r\n        mergedArray[k] = arrayToMerge[i];\r\n        animationArray.push([i,k]);\r\n        i++;\r\n      }else{\r\n        mergedArray[k] = arrayToMerge[j];\r\n        animationArray.push([j,k]);\r\n        j++;\r\n      }\r\n    }\r\n  }\r\n  //Signal to end the current animation\r\n  animationArray.push(0);\r\n  return [mergedArray, animationArray];\r\n}\r\n","export default function quickSort(arrayToSort){\r\n  let sortedArray = [];\r\n  let animationArray = [];\r\n  let pivotIndex;\r\n  if (arrayToSort.length < 2) { return [arrayToSort, animationArray]; }\r\n  pivotIndex = getMedianPivotIndex(arrayToSort, 0, arrayToSort.length - 1, animationArray);\r\n  [sortedArray, animationArray] = quickSortRecursiveCall(arrayToSort, pivotIndex, 0, arrayToSort.length - 1, animationArray);\r\n  return [sortedArray, animationArray];\r\n}\r\n\r\nfunction quickSortRecursiveCall(arrayToSort, pivotIndex, leftIndex, rightIndex, animationArray){\r\n  //Recursion exit condition\r\n  if (rightIndex - leftIndex < 1) { return [arrayToSort, animationArray]}\r\n\r\n  //Swap the pivot to the lowest position in the section of array to be sorted\r\n  [arrayToSort, animationArray] = swapBars(arrayToSort, pivotIndex, leftIndex, pivotIndex, animationArray);\r\n  //Then, partition the array\r\n  [arrayToSort, pivotIndex, animationArray] = partitionArray(arrayToSort, leftIndex, rightIndex, animationArray);\r\n  //We now have an array that is partioned with all values lower than the pivotValue\r\n  //to the left, and all larger to the right.\r\n  //Recursively call this on each half.\r\n  const leftPivot = getMedianPivotIndex(arrayToSort,\r\n                                        leftIndex,\r\n                                        pivotIndex - 1);\r\n  const rightPivot = getMedianPivotIndex(arrayToSort,\r\n                                        pivotIndex + 1,\r\n                                        rightIndex);\r\n\r\n  [arrayToSort, animationArray] = quickSortRecursiveCall(arrayToSort, leftPivot, leftIndex, pivotIndex - 1, animationArray);\r\n  [arrayToSort, animationArray] = quickSortRecursiveCall(arrayToSort, rightPivot, pivotIndex + 1, rightIndex, animationArray);\r\n\r\n  return [arrayToSort, animationArray];\r\n}\r\n\r\nfunction partitionArray(arrayToSort, leftIndex, rightIndex, animationArray){\r\n  //Pivot value is in the left most slot of this array\r\n  const pivotValue = arrayToSort[leftIndex].barHeight;\r\n  //Initialize the pivot index\r\n  let travellingPivotIndex = leftIndex + 1;\r\n  /*\r\n  Iterate over all the values in the segment defined by leftIndex and rightIndex\r\n  If the values are less than the pivotValue, swap the value to the leading edge\r\n  of the lower partition (ie j) and increment the travellingPivotIndex to move\r\n  the boundary.\r\n  */\r\n  for (let i = leftIndex + 1; i <= rightIndex; i++) {\r\n    if (arrayToSort[i].barHeight < pivotValue) {\r\n      [arrayToSort, animationArray] = swapBars(arrayToSort, i, travellingPivotIndex, leftIndex, animationArray);\r\n      travellingPivotIndex++;\r\n    }\r\n  }\r\n  //After looping, insert the pivot to the left of the travellingPivotIndex\r\n  [arrayToSort, animationArray] = swapBars(arrayToSort, leftIndex, travellingPivotIndex - 1, leftIndex, animationArray);\r\n\r\n  return [arrayToSort, travellingPivotIndex - 1, animationArray];\r\n}\r\n\r\n\r\nfunction getMedianPivotIndex(arrayToSort, leftIndex, rightIndex){\r\n  //Returns the index of the median value of the set of indices:\r\n  //leftIndex, median(leftIndex, rightIndex), rightIndex\r\n\r\n  //If the left and right indices are within one index of each other,\r\n  //return the low (though it doesn't matter)\r\n  if (rightIndex - leftIndex < 2) { return leftIndex }\r\n\r\n  const medIndex = Math.floor((leftIndex + rightIndex) / 2);\r\n\r\n  //Create an array of objects for each index\r\n  const indexObjectArray = [leftIndex, medIndex, rightIndex].map((element) => ({\r\n      index: element,\r\n      value: arrayToSort[element].barHeight\r\n  }))\r\n\r\n  //Calculate the lowest and highest values\r\n  const lowestIndexVal = indexObjectArray.reduce((accumulator, element) => (\r\n    Math.min(accumulator, element.value)),\r\n    Infinity);\r\n\r\n  const highestIndexVal = indexObjectArray.reduce((accumulator, element) => (\r\n    Math.max(accumulator, element.value)),\r\n    -Infinity);\r\n\r\n  //Filter the array to the object that is not the highest or lowest value\r\n  const medObject = indexObjectArray.filter((element) => (\r\n            element.value !== lowestIndexVal &&\r\n            element.value !== highestIndexVal));\r\n\r\n  //Return if we have a value (may not if two duplicate values)\r\n  if (medObject.length === 1){return medObject[0].index;}\r\n\r\n  //Otherwise, we have at least one duplicate, so just return the low value\r\n  return indexObjectArray[0].index;\r\n}\r\n\r\nfunction swapBars(arrayToSort, indexOne, indexTwo, pivotIndex, animationArray){\r\n  const originalArray = arrayToSort.slice();\r\n  const indexOneValue = originalArray[indexOne];\r\n  const indexTwoValue = originalArray[indexTwo];\r\n  arrayToSort[indexOne] = indexTwoValue;\r\n  arrayToSort[indexTwo] = indexOneValue;\r\n  animationArray.push([indexOne, indexTwo, pivotIndex]);\r\n  return [arrayToSort, animationArray];\r\n}\r\n","export default function bubbleSort(arrayToSort){\r\n  //Basically, just pass over the entire array with a window of size 2\r\n  //If values are out of order, swap them\r\n  let animationArray = [];\r\n  if (arrayToSort.length < 2) { return [arrayToSort, animationArray] }\r\n  let swapCounter = 0;\r\n  do {\r\n    swapCounter = 0;\r\n    for (let i = 0; i < arrayToSort.length - 1; i++){\r\n        if (arrayToSort[i].barHeight > arrayToSort[i+1].barHeight) {\r\n          [arrayToSort, animationArray] = swapBars(arrayToSort, i, i+1, animationArray);\r\n          swapCounter++;\r\n        }\r\n    }\r\n  } while (swapCounter > 0);\r\n  return [arrayToSort, animationArray];\r\n}\r\n\r\nfunction swapBars(arrayToSort, indexOne, indexTwo, animationArray){\r\n  const originalArray = arrayToSort.slice();\r\n  const indexOneValue = originalArray[indexOne];\r\n  const indexTwoValue = originalArray[indexTwo];\r\n  arrayToSort[indexOne] = indexTwoValue;\r\n  arrayToSort[indexTwo] = indexOneValue;\r\n  animationArray.push([indexOne, indexTwo]);\r\n  return [arrayToSort, animationArray];\r\n}\r\n","export default function heapSort( arrayToSort ) {\r\n\r\n  let animationArray = [];\r\n\r\n  if ( arrayToSort.length < 2 ) {\r\n    return [ arrayToSort, animationArray ]\r\n  }\r\n  const arrayLength = arrayToSort.length;\r\n\r\n  //Iterate over all nodes save for the leaves (any index past n/2-1 is a leaf)\r\n  //Start at the deepest nodes, work shallower, allowing the recursion to fix\r\n  for ( let i = Math.floor( arrayLength / 2 ) - 1; i >= 0; i-- ) {\r\n    [ arrayToSort, animationArray ] = heapSortRecursiveCall( arrayToSort, i,\r\n      arrayLength, animationArray );\r\n  }\r\n\r\n  //Pick off the roots one by one, and re-heapify remainder\r\n  for ( let i = arrayLength - 1; i > 0; i-- ) {\r\n    let prevRoot = arrayToSort[ 0 ];\r\n    //Swap root with one of the leaves at the end of the array;\r\n    [ arrayToSort, animationArray ] = swapBars( arrayToSort, 0, i,\r\n      animationArray );\r\n    //Re-heapify the remaining array\r\n    [ arrayToSort, animationArray ] = heapSortRecursiveCall( arrayToSort, 0, i,\r\n      animationArray );\r\n  }\r\n\r\n  return [ arrayToSort, animationArray ];\r\n}\r\n\r\nfunction heapSortRecursiveCall( arrayToSort, rootIndex, arrayLength,\r\n  animationArray ) {\r\n  //Assume the array is a binary tree that, for every index i\r\n  //Has left child in index 2 * i + 1\r\n  //Has right child in index 2 * i + 2\r\n  //If these indices are out of bounds, child does not exist\r\n\r\n  //Assume value at root is the smallest\r\n  let smallestIndex = rootIndex;\r\n\r\n  //Get value of left and right children\r\n  const leftIndex = 2 * rootIndex + 1;\r\n  const rightIndex = 2 * rootIndex + 2;\r\n\r\n  //Compare the root and left child and save the smaller\r\n  if ( ( leftIndex < arrayLength ) && ( arrayToSort[ leftIndex ].barHeight >\r\n      arrayToSort[ smallestIndex ].barHeight ) ) {\r\n    smallestIndex = leftIndex;\r\n  }\r\n  //Compare the smaller of root and left with right and save the smaller\r\n  if ( ( rightIndex < arrayLength ) && ( arrayToSort[ rightIndex ].barHeight >\r\n      arrayToSort[ smallestIndex ].barHeight ) ) {\r\n    smallestIndex = rightIndex;\r\n  }\r\n  //Check to see if we are changing anything. If so, cascade down changed branch\r\n  if ( smallestIndex !== rootIndex ) {\r\n    [ arrayToSort, animationArray ] = swapBars( arrayToSort, rootIndex,\r\n      smallestIndex, animationArray );\r\n    [ arrayToSort, animationArray ] = heapSortRecursiveCall( arrayToSort,\r\n      smallestIndex, arrayLength, animationArray );\r\n  }\r\n\r\n  return [ arrayToSort, animationArray ];\r\n}\r\n\r\nfunction swapBars( arrayToSort, indexOne, indexTwo, animationArray ) {\r\n  const originalArray = arrayToSort.slice();\r\n  const indexOneValue = originalArray[ indexOne ];\r\n  const indexTwoValue = originalArray[ indexTwo ];\r\n  arrayToSort[ indexOne ] = indexTwoValue;\r\n  arrayToSort[ indexTwo ] = indexOneValue;\r\n  animationArray.push( [ indexOne, indexTwo ] );\r\n  return [ arrayToSort, animationArray ];\r\n}","import React from 'react'\r\nimport VerticalBarContainer from './VerticalBars/VerticalBarContainer.jsx';\r\nimport ControlContainer from './ControlBar/ControlContainer.jsx';\r\nimport mergeSort from './mergeSort.js'\r\nimport quickSort from './quickSort.js'\r\nimport bubbleSort from './bubbleSort.js'\r\nimport heapSort from './heapSort.js'\r\nimport './App.css';\r\n\r\nconst BAR_COUNT = 250;\r\nconst REFRESH_RATE = 20;\r\nconst TEST_ARRAY_COUNT = 100;\r\nconst TEST_ARRAY_MAX_LENGTH = 1000;\r\nconst TEST_ARRAY_VALUE_MAX = 15000;\r\n\r\nexport default class App extends React.Component {\r\n  constructor( props ) {\r\n    super( props );\r\n    this.state = {\r\n      barObjects: []\r\n    };\r\n    this.resetBars = this.resetBars.bind( this );\r\n    this.mergeSortWrapper = this.mergeSortWrapper.bind( this );\r\n    this.quickSortWrapper = this.quickSortWrapper.bind( this );\r\n    this.bubbleSortWrapper = this.bubbleSortWrapper.bind( this );\r\n    this.heapSortWrapper = this.heapSortWrapper.bind( this );\r\n    this.animateMergeSort = this.animateMergeSort.bind( this );\r\n    this.animateQuickSort = this.animateQuickSort.bind( this );\r\n    this.animateBubbleSort = this.animateBubbleSort.bind( this );\r\n    this.animateHeapSort = this.animateHeapSort.bind( this );\r\n    this.testSort = this.testSort.bind( this );\r\n  }\r\n\r\n  componentDidMount() {\r\n    this.resetBars( BAR_COUNT );\r\n  }\r\n\r\n  resetBars( barCount ) {\r\n    let arr = []\r\n    for ( let i = 0; i < barCount; i++ ) {\r\n      arr.push( {\r\n        barHeight: Math.floor( 900 * Math.random() + 100 ),\r\n        currentBar: false,\r\n        partitionBar: false\r\n      } );\r\n    }\r\n    this.setState( ( state, props ) => ( {\r\n      barObjects: arr\r\n    } ) );\r\n  }\r\n\r\n  mergeSortWrapper() {\r\n    let sortedArray = [];\r\n    let animationArray = [];\r\n\r\n    [ sortedArray, animationArray ] = mergeSort( this.state.barObjects\r\n      .slice() );\r\n    this.animateMergeSort( this.state.barObjects, animationArray );\r\n  }\r\n\r\n  quickSortWrapper() {\r\n    let sortedArray = [];\r\n    let animationArray = [];\r\n    [ sortedArray, animationArray ] = quickSort( this.state.barObjects\r\n      .slice() );\r\n    this.animateQuickSort( this.state.barObjects, animationArray );\r\n  }\r\n\r\n  bubbleSortWrapper() {\r\n    let sortedArray = [];\r\n    let animationArray = [];\r\n    [ sortedArray, animationArray ] = bubbleSort( this.state.barObjects\r\n      .slice() );\r\n    this.animateBubbleSort( this.state.barObjects, animationArray );\r\n  }\r\n\r\n  heapSortWrapper() {\r\n    let sortedArray = [];\r\n    let animationArray = [];\r\n    [ sortedArray, animationArray ] = heapSort( this.state.barObjects\r\n      .slice() );\r\n    this.animateHeapSort( this.state.barObjects, animationArray );\r\n  }\r\n\r\n  testSort() {\r\n    //Populate testing array\r\n    const arrayToSort = [ TEST_ARRAY_COUNT ];\r\n    for ( let i = 0; i < TEST_ARRAY_COUNT; i++ ) {\r\n      let testArrayLength = Math.floor( Math.random() *\r\n        TEST_ARRAY_MAX_LENGTH + 1 )\r\n      arrayToSort[ i ] = [];\r\n      for ( let j = 0; j < testArrayLength; j++ ) {\r\n        arrayToSort[ i ].push( {\r\n          barHeight: Math.floor( Math.random() *\r\n            TEST_ARRAY_VALUE_MAX )\r\n        } );\r\n      }\r\n    }\r\n\r\n    //Run the sorting algorithms on the arrays\r\n    for ( let i = 0; i < arrayToSort.length; i++ ) {\r\n      const [ mergeSortedArray, ] = mergeSort( arrayToSort[ i ] );\r\n      const [ quickSortedArray, ] = quickSort( arrayToSort[ i ] );\r\n      const [ bubbleSortedArray, ] = bubbleSort( arrayToSort[ i ] );\r\n      const [ heapSortedArray, ] = heapSort( arrayToSort[ i ] );\r\n      const jsSortedArray = arrayToSort[ i ].sort( ( a, b ) => a.barHeight -\r\n        b\r\n        .barHeight );\r\n\r\n      if ( this.arraysEqual( mergeSortedArray, jsSortedArray ) ) {\r\n        console.log( \"Merge Sort Working Properly\" );\r\n      } else {\r\n        console.log( \"Merge Sort Failed\" );\r\n        console.log( arrayToSort[ i ] );\r\n        console.log( mergeSortedArray );\r\n      }\r\n      if ( this.arraysEqual( quickSortedArray, jsSortedArray ) ) {\r\n        console.log( \"Quick Sort Working Properly\" );\r\n      } else {\r\n        console.log( 'Quick Sort Failed' );\r\n        console.log( arrayToSort[ i ] );\r\n        console.log( mergeSortedArray );\r\n      }\r\n      if ( this.arraysEqual( bubbleSortedArray, jsSortedArray ) ) {\r\n        console.log( \"Bubble Sort Working Properly\" );\r\n      } else {\r\n        console.log( 'Bubble Sort Failed' );\r\n        console.log( arrayToSort[ i ] );\r\n        console.log( mergeSortedArray );\r\n      }\r\n      if ( this.arraysEqual( heapSortedArray, jsSortedArray ) ) {\r\n        console.log( \"Heap Sort Working Properly\" );\r\n      } else {\r\n        console.log( 'Heap Sort Failed' );\r\n        console.log( arrayToSort[ i ] );\r\n        console.log( mergeSortedArray );\r\n      }\r\n    }\r\n  }\r\n\r\n  arraysEqual( a, b ) {\r\n    if ( a === b ) return true;\r\n    if ( a == null || b == null ) return false;\r\n    if ( a.length !== b.length ) return false;\r\n\r\n    for ( var i = 0; i < a.length; ++i ) {\r\n      if ( a[ i ].barHeight !== b[ i ].barHeight ) {\r\n        return false\r\n      }\r\n\r\n    }\r\n    return true;\r\n  }\r\n\r\n  animateMergeSort( unsortedArray, animationArray ) {\r\n    //let originalArray = unsortedArray.slice();\r\n    let tempArray = unsortedArray.slice();\r\n    let skippedSteps = 0;\r\n    let cache = [];\r\n\r\n    for ( let i = 0; i < animationArray.length; i++ ) {\r\n      //Read current operation from animation array\r\n      let opArray = animationArray[ i ];\r\n      //If we have a 0, then the particular merge is done,\r\n      //and we can use the created array as the new baseline\r\n      if ( opArray === 0 ) {\r\n        //originalArray = tempArray.slice();\r\n        continue;\r\n      }\r\n      let locationOne = opArray[ 0 ];\r\n      let locationTwo = opArray[ 1 ];\r\n      //If the operation results in no change, skip this index\r\n      if ( locationOne < locationTwo ) {\r\n        skippedSteps++;\r\n        continue;\r\n      }\r\n      //If we are past the first animation, unhighlight the bar that was\r\n      //highlighted in the previous step\r\n      if ( cache.length > 0 ) {\r\n        tempArray = this.undoLastAnimation( tempArray, cache )\r\n          .slice()\r\n      }\r\n      [ tempArray, cache ] = this.processAnimation( 'insert', tempArray,\r\n        locationOne, locationTwo )\r\n      let newArray = tempArray.slice();\r\n      //Set the state every 20ms (delaying a further 20ms each successful step)\r\n      setTimeout( () => (\r\n        this.setState( {\r\n          barObjects: newArray\r\n        } ) ), REFRESH_RATE * ( i - skippedSteps ) )\r\n    }\r\n  }\r\n\r\n  animateQuickSort( unsortedArray, animationArray ) {\r\n    let originalArray = unsortedArray.slice();\r\n    let skippedSteps = 0;\r\n    let cache = [];\r\n\r\n    for ( let i = 0; i < animationArray.length; i++ ) {\r\n\r\n      let opArray = animationArray[ i ];\r\n      let locationOne = opArray[ 0 ];\r\n      let locationTwo = opArray[ 1 ];\r\n      let pivotIndex = opArray[ 2 ];\r\n\r\n      //If the operation results in no change, skip this index\r\n      if ( locationOne === locationTwo ) {\r\n        skippedSteps++;\r\n        continue;\r\n      }\r\n\r\n      //Unhighlight current and pivots from last iteration\r\n      if ( cache.length > 0 ) {\r\n        originalArray = this.undoLastAnimation( originalArray, cache )\r\n          .slice()\r\n      }\r\n\r\n      [ originalArray, cache ] = this.processAnimation( 'swap with pivot',\r\n        originalArray, locationOne, locationTwo, pivotIndex )\r\n\r\n      let newArray = originalArray.slice();\r\n      //Set the state every 20ms (delaying a further 20ms each successful step)\r\n      setTimeout( () => (\r\n        this.setState( {\r\n          barObjects: newArray\r\n        } ) ), REFRESH_RATE * ( i - skippedSteps ) )\r\n    }\r\n\r\n  }\r\n\r\n  animateBubbleSort( unsortedArray, animationArray ) {\r\n    let originalArray = unsortedArray.slice();\r\n    let skippedSteps = 0;\r\n    let cache = [];\r\n\r\n    for ( let i = 0; i < animationArray.length; i++ ) {\r\n\r\n      let opArray = animationArray[ i ];\r\n      let locationOne = opArray[ 0 ];\r\n      let locationTwo = opArray[ 1 ];\r\n\r\n      //If the operation results in no change, skip this index\r\n      if ( locationOne === locationTwo ) {\r\n        skippedSteps++;\r\n        continue;\r\n      }\r\n\r\n      //Unhighlight current and pivots from last iteration\r\n      if ( cache.length > 0 ) {\r\n        originalArray = this.undoLastAnimation( originalArray, cache )\r\n          .slice()\r\n      }\r\n\r\n      [ originalArray, cache ] = this.processAnimation( 'swap',\r\n        originalArray, locationOne, locationTwo )\r\n\r\n      let newArray = originalArray.slice();\r\n      //Set the state every 20ms (delaying a further 20ms each successful step)\r\n      setTimeout( () => (\r\n        this.setState( {\r\n          barObjects: newArray\r\n        } ) ), REFRESH_RATE * ( i - skippedSteps ) )\r\n    }\r\n\r\n  }\r\n\r\n  animateHeapSort( unsortedArray, animationArray ) {\r\n    let originalArray = unsortedArray.slice();\r\n    let skippedSteps = 0;\r\n    let cache = [];\r\n\r\n    for ( let i = 0; i < animationArray.length; i++ ) {\r\n\r\n      let opArray = animationArray[ i ];\r\n      let locationOne = opArray[ 0 ];\r\n      let locationTwo = opArray[ 1 ];\r\n\r\n      //If the operation results in no change, skip this index\r\n      if ( locationOne === locationTwo ) {\r\n        skippedSteps++;\r\n        continue;\r\n      }\r\n\r\n      //Unhighlight current and pivots from last iteration\r\n      if ( cache.length > 0 ) {\r\n        originalArray = this.undoLastAnimation( originalArray, cache )\r\n          .slice()\r\n      }\r\n\r\n      [ originalArray, cache ] = this.processAnimation( 'swap',\r\n        originalArray, locationOne, locationTwo )\r\n\r\n      let newArray = originalArray.slice();\r\n      //Set the state every 20ms (delaying a further 20ms each successful step)\r\n      setTimeout( () => (\r\n        this.setState( {\r\n          barObjects: newArray\r\n        } ) ), REFRESH_RATE * ( i - skippedSteps ) )\r\n    }\r\n\r\n  }\r\n\r\n  processAnimation( animType, arrayToAnim, indexOne, indexTwo, pivotIndex ) {\r\n    if ( animType === 'insert' ) {\r\n      //By convention, take the value at index one, and insert at index two\r\n      let barToMove = JSON.parse(\r\n        JSON.stringify( arrayToAnim[ indexOne ] )\r\n      );\r\n      barToMove.currentBar = true;\r\n      arrayToAnim.splice( indexOne, 1 );\r\n      arrayToAnim.splice( indexTwo, 0, barToMove );\r\n      let cache = [ animType, indexOne, indexTwo, barToMove ];\r\n      return [ arrayToAnim, cache ];\r\n    }\r\n    if ( animType === 'swap with pivot' ) {\r\n      //Take values at index one and two, and exchange, making both current\r\n      //Set the pivot index\r\n      //Special case is when we have indexOne === pivotIndex, which is where\r\n      //the pivot is being moved to/from the start of the partition\r\n      let barOne = JSON.parse(\r\n        JSON.stringify( arrayToAnim[ indexOne ] )\r\n      );\r\n      let barTwo = JSON.parse(\r\n        JSON.stringify( arrayToAnim[ indexTwo ] )\r\n      );\r\n      let barPivot = JSON.parse(\r\n        JSON.stringify( arrayToAnim[ pivotIndex ] )\r\n      );\r\n      barOne.currentBar = true;\r\n      barTwo.currentBar = true;\r\n      barPivot.partitionBar = true;\r\n      arrayToAnim[ indexOne ] = barTwo;\r\n      arrayToAnim[ indexTwo ] = barOne;\r\n      if ( indexOne !== pivotIndex ) {\r\n        arrayToAnim[ pivotIndex ] = barPivot;\r\n      }\r\n      let cache = [ animType, indexOne, indexTwo, barOne, barTwo,\r\n        pivotIndex, barPivot\r\n      ];\r\n      return [ arrayToAnim, cache ];\r\n    }\r\n    if ( animType === 'swap' ) {\r\n      //Take values at index one and two, and exchange, making both current\r\n      let barOne = JSON.parse(\r\n        JSON.stringify( arrayToAnim[ indexOne ] )\r\n      );\r\n      let barTwo = JSON.parse(\r\n        JSON.stringify( arrayToAnim[ indexTwo ] )\r\n      );\r\n      barOne.currentBar = true;\r\n      barTwo.currentBar = true;\r\n      arrayToAnim[ indexOne ] = barTwo;\r\n      arrayToAnim[ indexTwo ] = barOne;\r\n      let cache = [ animType, indexOne, indexTwo, barOne, barTwo, ];\r\n      return [ arrayToAnim, cache ];\r\n    }\r\n  }\r\n\r\n  undoLastAnimation( arrayToAnim, cache ) {\r\n    const animType = cache[ 0 ];\r\n    if ( animType === 'insert' ) {\r\n      let [ , indexOne, indexTwo, barOne ] = cache;\r\n      barOne = JSON.parse( JSON.stringify( barOne ) );\r\n      barOne.currentBar = false;\r\n      arrayToAnim[ indexTwo ] = barOne;\r\n      return arrayToAnim;\r\n    }\r\n    if ( animType === 'swap with pivot' ) {\r\n      let [ , indexOne, indexTwo, barOne, barTwo, pivotIndex, barPivot ] =\r\n      cache;\r\n      barOne = JSON.parse( JSON.stringify( barOne ) );\r\n      barTwo = JSON.parse( JSON.stringify( barTwo ) );\r\n      barPivot = JSON.parse( JSON.stringify( barPivot ) );\r\n      barOne.currentBar = false;\r\n      barTwo.currentBar = false;\r\n      barPivot.partitionBar = false;\r\n      arrayToAnim[ indexOne ] = barTwo;\r\n      arrayToAnim[ indexTwo ] = barOne;\r\n      if ( indexOne !== pivotIndex ) {\r\n        arrayToAnim[ pivotIndex ] = barPivot;\r\n      }\r\n      return arrayToAnim;\r\n    }\r\n    if ( animType === 'swap' ) {\r\n      let [ , indexOne, indexTwo, barOne, barTwo ] =\r\n      cache;\r\n      barOne = JSON.parse( JSON.stringify( barOne ) );\r\n      barTwo = JSON.parse( JSON.stringify( barTwo ) );\r\n      barOne.currentBar = false;\r\n      barTwo.currentBar = false;\r\n      arrayToAnim[ indexOne ] = barTwo;\r\n      arrayToAnim[ indexTwo ] = barOne;\r\n      return arrayToAnim;\r\n    }\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <div className='app-container'>\r\n        <ControlContainer barCount={BAR_COUNT}\r\n                          resetBars={this.resetBars}\r\n                          mergeSort={this.mergeSortWrapper}\r\n                          quickSort={this.quickSortWrapper}\r\n                          bubbleSort={this.bubbleSortWrapper}\r\n                          heapSort={this.heapSortWrapper}\r\n                          testSort={this.testSort} />\r\n        <VerticalBarContainer barState={this.state} />\r\n      </div>\r\n    )\r\n  }\r\n}","const reportWebVitals = onPerfEntry => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry);\r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n};\r\n\r\nexport default reportWebVitals;\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport reportWebVitals from './reportWebVitals';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}